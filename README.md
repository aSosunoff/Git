# GIT

`init`

> создание директории .git, слежение за изменением файлов

---

## add - _добавление изменений в индекс_

`.`

> добавление в индекс всех файлов в текущей директории директории и поддиректории

`-A`

> добавление в индекс всех файлов от корня проекта

---

## commit - _добавление изменений в репозиторий_

> добавление файлов из индекса в репозиторий с предварительным вызовом редактора для коментария изменений

`-m "{comment}"`

> добавление файлов из индекса в репозиторий без вызова редактора, но с маленьким коментом

`-a`

> добавление файлов из рабочей области в индекс и в репозирий (только файлов которые ранее были в индексе)

`-am "{comment}"`

> добавление файлов из рабочей области в индекс и в репозирий с коментом (только файлов которые ранее были в индексе)

`-c ORIG_HEAD`

> берём описание из существующего. на случий когда сделали мягкий ресет. при этом откроется редактор для редактирования сообщения взятого с вершины

`-С ORIG_HEAD`

> берём описание из существующего. на случий когда сделали мягкий ресет. сообщение берётся как есть

---

## rm - _удаление_

`{file_name}`

> удаление файла из рабочей области

`--сached {file_name}`

> удаление файла из индекса, но не из рабочей директории

`-r {dir_name}`

> удаление директории из рабочей области

`-r --сached {dir_name}`

> удаление директории из индекса, но не из рабочей директории

---

## mv - _переименование файлов_

`{file_name} {file_name_2}`

> переименование файлов

---

## restore - _вынесение изменений из индекса_

`--staged {file_name}`

> вынесение из индекса ещё не закомиченых файлов

---

## branch - _работа с ветками_

> показывает какие есть ветки

`-v`

> показывает какие есть ветки с дополнительной информацией

`{name_new_branch}`

> создание новой ветки с именем

`{name_branch} {number_commit}`

> создаст ветку с указанным комитом

`-f {name_branch} {number_commit}`

> перенесёт ветку на указанный комит или ветку так как ветка это просто ссылка на коммит

`-f {name_branch} ORIG_HEAD`

> если при merge поняли, что поторопились со слиянием, то можно всё вернуть

`-d {name_branch}`

> удаление ссылки ветки, оставляя при этом все коммиты. работает только в том случае если ветка обьединена с текущей

`-D {name_branch}`

> удаляет ветку с комитами

---

## checkout - _перемещение по коммитам_

`{name_branch/number_commit}`

> переключение на другую ветку или коммит

`-b {name_branch}`

> создание новой ветки и переключение на неё

`-B {name_branch} {number_commit}`

> перенос ссылки ветки на новую ссылку комита и переключение за эту ветку

`-f {name_branch}`

> переключение на другую ветку, потеря не закомиченных изменений

`-f HEAD`

> переключение на текущую ветку при этом все незакомиченные изменения пропадут. (можно без указания HEAD или такое обозначение -> @, он идёт по умолчанию)

`{name_branch} {name_file}`

> откатывает файл. при этом добавляет в индекс для нового коммита

`{path}`

> откатывает изменения из индекса в рабочую директорию

`HEAD {path}`

> откатывает изменения из репозитория и индекса в рабочую директорию

`-- {path}`

> всё что после 2 дифиса воспринимается как путь. 2 дифис нужен когда ситуация неопределённая. например ветка и папка имеют одно имя

---

## stash - _отложенные изменений_

> архивируем не закомиченные изменения

`pop`

> возырвщвем архивируемые изменения

---

## log - _история_

> история коммитов

`--oneline`

> история коммитов в одну строку

`--oneline {name_branch/number_commit}`

> история конкретной ветки или комита в одну строку

`--oneline -g`

> переключает log в особое отображение рефлогов

---

## reflog - _история ссылок_

> показывает рефлоги

`--date=iso`

> показывает рефлоги с датой в формате iso

---

## show - _информация_

> информация о коммите (по дефолту HEAD или такое обозначение -> @)

`{name_branch/number_commit}`

> информация о конкретном комите или ветки

`{name_branch/number_commit}~`

> информация от конкретного комита или ветки вниз (сколько ~ столько шагов по истории вниз)

`{name_branch/number_commit}~2`

> информация от конкретного комита или ветки вниз (какое число после ~ столько шагов вниз по истории)

`@~:{name_file}`

> просмотр файла

`@~2:{name_file}`

> просмотр файла

`fix:{name_file}`

> просмотр файла на ветке fix

`:{name_file}`

> просмотр файла который в индексе

`:/{any_word}`

> просмотр файла в котором встретиться слово. возвращает самый свежий комит. ищет с любой ветки

---

## merge - _слияние_

`{name_branch/number_commit}`

> слияние веток перемоткой

---

## tag - _теги_

> выводит все теги

`{name_tag} {branch/number_commit/HEAD}`

> создание метки для коммита

`--contains {number_commit}`

> выводит теги которые указывают на комит

`-n`

> дополнительно выводит сообщение на коммите

`-n -l '{name_tag}*'`

> выводит теги по маске

`-d {name_tag}`

> удвление указанных тегов

`-a -m '{message}' {name_tag} {number_commit/branch/HEAD}`

> создание тега с аннотацией

---

## describe - _ближайшие теги_

> покажет ближайший анотированный тег

---

## archive - _архивируем коммиты_

`-o {path} HEAD`

> архивируем

---

## reset - _отмена коммитов и удаление не закомиченных изменений_

`--hard`

> откатываем изменения из индекса и рабочей директории текущего коммита и удаляем коммиты

`--hard {number_commit/@~/@~~/@~3/...}`

> откатываем на заданный коммит и удаляем коммиты

`--hard ORIG_HEAD`

> возвращаемся на коммит который заресетили

`--soft {@~/@~2/...}`

> оставляет файлы коммита с которого ушли. (как бы отминили коммит, обычно что бы переделать неудачные коммиты)
