# git > 

### > init
* создание директории .git, слежение за изменением файлов
---
## add
`.`
> добавление в индекс всех файлов в текущей директории директории и поддиректории

`-A`

> добавление в индекс всех файлов от корня проекта

---
## commit

> добавление файлов из индекса в репозиторий с предварительным вызовом редактора для коментария изменений

`-m "{comment}"`

> добавление файлов из индекса в репозиторий без вызова редактора, но с маленьким коментом

`-a`

> добавление файлов из рабочей области в индекс и в репозирий (только файлов которые ранее были в индексе)

`-am "{comment}"`

> добавление файлов из рабочей области в индекс и в репозирий с коментом (только файлов которые ранее были в индексе)

---

### > git rm <file_name>
* удаление файла из рабочей области
### > git rm --сached <file_name>
* удаление файла из индекса
### > git rm -r <dir_name>
* удаление директории из рабочей области
### > git rm -r --сached <dir_name>
* удаление директории из индекса
---
### > git mv <file_name> <file_name_2>
* переименование файлов
---
### > git restore --staged <file_name>
* вынесение из индекса ещё не закомиченых файлов
---
### > git branch
* показывает какие есть ветки
### > git branch -v
* показывает какие есть ветки с дополнительной информацией
### > git branch <name_new_branch >
* создание новой ветки с именем
### > git branch <name_branch> <number_commit>
* создаст ветку с указанным комитом
### > git branch -f <name_branch> <number_commit>
* перенесёт ветку на указанный комит или ветку так как ветка это просто ссылка на коммит
### git branch -f <name_branch> ORIG_HEAD
* если при merge поняли, что поторопились со слиянием, то можно всё вернуть
### git branch -d <name_branch>
* удаление ссылки ветки, оставляя при этом все коммиты. работает только в том случае если ветка обьединена с текущей
### git branch -D <name_branch>
* удаляет ветку с комитами
---
### > git checkout <name_branch/number_commit>
* переключение на другую ветку или коммит
### > git checkout -b <name_branch>
* создание новой ветки и переключение на неё
### > git checkout -B <name_branch> <number_commit>
* перенос ссылки ветки на новую ссылку комита и переключение за эту ветку
### > git checkout -f <name_branch>
* переключение на другую ветку, потеря не закомиченных изменений
### > git checkout -f HEAD
* переключение на текущую ветку при этом все незакомиченные изменения пропадут. (можно без указания HEAD или такое обозначение -> @, он идёт по умолчанию)
### > git checkout <name_branch> <name_file>
* откатывает файл. при этом добавляет в индекс для нового коммита
### > git checkout <path>
* откатывает изменения из индекса в рабочую директорию
### > git checkout HEAD <path>
* откатывает изменения из репозитория и индекса в рабочую директорию
### > git checkout -- <path>
* всё что после 2 дифиса воспринимается как путь. 2 дифис нужен когда ситуация неопределённая. например ветка и папка имеют одно имя
---
### > git stash
* архивируем не закомиченные изменения
### > git stash pop
* возырвщвем архивируемые изменения
---
### > git log
* история коммитов
### > git log --oneline
* история коммитов в одну строку
### > git log --oneline <name_branch/number_commit>
* история конкретной ветки или комита в одну строку
### > git log --oneline -g
* переключает log в особое отображение рефлогов
---
### > git reflog
* показывает рефлоги
### > git reflog --date=iso
* показывает рефлоги с датой в формате iso
---
### > git show
* информация о коммите (по дефолту HEAD или такое обозначение -> @)
### > git show <name_branch/number_commit>
* информация о конкретном комите или ветки
### > git show <name_branch/number_commit>~
* информация от конкретного комита или ветки вниз (сколько ~ столько шагов по истории вниз)
### > git show <name_branch/number_commit>~2
* информация от конкретного комита или ветки вниз (какое число после ~ столько шагов вниз по истории)
### > git show @~:index.html
* просмотр файла
### > git show @~2:index.html
* просмотр файла
### > git show fix:index.html
* просмотр файла на ветке fix
### > git show :index.html
* просмотр файла который в индексе
### > git show :/<any_word>
* просмотр файла в котором встретиться слово. возвращает самый свежий комит. ищет с любой ветки
---
### > git merge <name_branch/number_commit>
* слияние веток перемоткой
---
### > git tag
* выводит все теги
### > git tag <name_tag> <branch/number_commit/HEAD>
* создание метки для коммита
### > git tag --contains <number_commit>
* выводит теги которые указывают на комит
### > git tag -n
* дополнительно выводит сообщение на коммите
### > git tag -n -l 'v1*'
* выводит теги по маске
### > git tag -d <name_tag>
* удвление указанных тегов
### > git tag -a -m '{message}' {name_tag} {number_commit/branch/HEAD}
* создание тега с аннотацией
---
### > git describe
* покажет ближайший анотированный тег