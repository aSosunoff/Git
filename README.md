# git > 

### > init
* создание директории .git, слежение за изменением файлов
---
## add
`.`
> добавление в индекс всех файлов в текущей директории директории и поддиректории

`-A`

> добавление в индекс всех файлов от корня проекта

---
## commit

> добавление файлов из индекса в репозиторий с предварительным вызовом редактора для коментария изменений

`-m "{comment}"`

> добавление файлов из индекса в репозиторий без вызова редактора, но с маленьким коментом

`-a`

> добавление файлов из рабочей области в индекс и в репозирий (только файлов которые ранее были в индексе)

`-am "{comment}"`

> добавление файлов из рабочей области в индекс и в репозирий с коментом (только файлов которые ранее были в индексе)

---

## rm 

`{file_name}`

> удаление файла из рабочей области

`--сached {file_name}`

> удаление файла из индекса

`-r {dir_name}`

> удаление директории из рабочей области

`-r --сached {dir_name}`

> удаление директории из индекса

---

## mv

`{file_name} {file_name_2}`

> переименование файлов

---

## restore

`--staged {file_name}`

> вынесение из индекса ещё не закомиченых файлов

---

## branch

> показывает какие есть ветки

`-v`

> показывает какие есть ветки с дополнительной информацией

`{name_new_branch}`

> создание новой ветки с именем

`{name_branch} {number_commit}`

> создаст ветку с указанным комитом

`-f {name_branch} {number_commit}`

> перенесёт ветку на указанный комит или ветку так как ветка это просто ссылка на коммит

`-f {name_branch} ORIG_HEAD`

> если при merge поняли, что поторопились со слиянием, то можно всё вернуть

`-d {name_branch}`

> удаление ссылки ветки, оставляя при этом все коммиты. работает только в том случае если ветка обьединена с текущей

`-D {name_branch}`

> удаляет ветку с комитами

---

## checkout

`{name_branch/number_commit}`

> переключение на другую ветку или коммит

`-b {name_branch}`

> создание новой ветки и переключение на неё

`-B {name_branch} {number_commit}`

> перенос ссылки ветки на новую ссылку комита и переключение за эту ветку

`-f {name_branch}`

> переключение на другую ветку, потеря не закомиченных изменений

`-f HEAD`

> переключение на текущую ветку при этом все незакомиченные изменения пропадут. (можно без указания HEAD или такое обозначение -> @, он идёт по умолчанию)

`{name_branch} {name_file}`

> откатывает файл. при этом добавляет в индекс для нового коммита

`{path}`

> откатывает изменения из индекса в рабочую директорию

`HEAD {path}`

> откатывает изменения из репозитория и индекса в рабочую директорию

`-- {path}`

> всё что после 2 дифиса воспринимается как путь. 2 дифис нужен когда ситуация неопределённая. например ветка и папка имеют одно имя

---

## stash

> архивируем не закомиченные изменения

`pop`

> возырвщвем архивируемые изменения

---

## log

> история коммитов

`--oneline`

> история коммитов в одну строку

`--oneline {name_branch/number_commit}`

> история конкретной ветки или комита в одну строку

`--oneline -g`

> переключает log в особое отображение рефлогов

---

## reflog

> показывает рефлоги

`--date=iso`

> показывает рефлоги с датой в формате iso

---

## show

> информация о коммите (по дефолту HEAD или такое обозначение -> @)

`{name_branch/number_commit}`

> информация о конкретном комите или ветки

`{name_branch/number_commit}~`

> информация от конкретного комита или ветки вниз (сколько ~ столько шагов по истории вниз)

`{name_branch/number_commit}~2`

> информация от конкретного комита или ветки вниз (какое число после ~ столько шагов вниз по истории)

`@~:{name_file}`

> просмотр файла

`@~2:{name_file}`

> просмотр файла

`fix:{name_file}`

> просмотр файла на ветке fix

`:{name_file}`

> просмотр файла который в индексе

`:/{any_word}`

> просмотр файла в котором встретиться слово. возвращает самый свежий комит. ищет с любой ветки

---

## merge 

`{name_branch/number_commit}`

> слияние веток перемоткой

---

## tag

> выводит все теги

`{name_tag} {branch/number_commit/HEAD}`

> создание метки для коммита

`--contains {number_commit}`

> выводит теги которые указывают на комит

`-n`

> дополнительно выводит сообщение на коммите

`-n -l '{name_tag}*'`

> выводит теги по маске

`-d {name_tag}`

> удвление указанных тегов

`-a -m '{message}' {name_tag} {number_commit/branch/HEAD}`

> создание тега с аннотацией

---

## describe

> покажет ближайший анотированный тег